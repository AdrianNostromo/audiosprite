// Generated by CoffeeScript 1.3.1
(function() {
  var appendFile, appendSilence, argv, async, child_process, exportFile, exportFileCaf, files, fs, json, mktemp, numChannels, offsetCursor, optimist, path, processFiles, spawn, tempFile, wavArgs, winston, _,
    __slice = [].slice;

  fs = require('fs');

  path = require('path');

  child_process = require('child_process');

  async = require('async');

  _ = require('underscore')._;

  winston = require('winston');

  optimist = require('optimist').options('output', {
    alias: 'o',
    "default": 'output',
    describe: 'Name for the output file.'
  }).options('log', {
    alias: 'l',
    "default": 'info',
    describe: 'Log level (debug, info, notice, warning, error).'
  }).options('autoplay', {
    alias: 'a',
    "default": null,
    describe: 'Autoplay sprite name'
  }).options('silence', {
    alias: 's',
    "default": 0,
    describe: 'Add special "silence" track with specified duration.'
  }).options('help', {
    alias: 'h',
    describe: 'Show this help message.'
  });

  argv = optimist.argv;

  winston.setLevels(winston.config.syslog.levels);

  winston.remove(winston.transports.Console);

  winston.add(winston.transports.Console, {
    colorize: true,
    level: argv.log,
    handleExceptions: true
  });

  winston.debug('Parsed arguments', argv);

  files = _.uniq(argv._);

  if (argv.help || !files.length) {
    if (!argv.help) {
      winston.error('No input files specified.');
    }
    winston.info('Usage: audio-sprite [options] file1.mp3 file2.mp3 *.wav');
    winston.info(optimist.help());
    return;
  }

  mktemp = function(prefix) {
    var tmpdir;
    tmpdir = process.env.TMPDIR || '.';
    return path.join(tmpdir, prefix + '.' + ~~(Math.random() * 1e6));
  };

  spawn = function(name, opt) {
    winston.debug('Spawn', {
      cmd: name + ' ' + opt.join(' ')
    });
    return child_process.spawn(name, opt);
  };

  appendFile = function(src, dest, cb) {
    var duration;
    winston.debug('Start processing', {
      file: src
    });
    duration = 0;
    return path.exists(src, function(exists) {
      var ffmpeg;
      if (!exists) {
        return cb({
          msg: 'File does not exist',
          file: src
        });
      }
      ffmpeg = spawn('ffmpeg', ['-i', path.resolve(src)].concat(wavArgs).concat('pipe:'));
      ffmpeg.stdout.pipe(fs.createWriteStream(dest, {
        flags: 'a'
      }));
      ffmpeg.stderr.on('data', function(data) {
        var match;
        if (match = data.toString('utf8').match(/\s*Duration:\s+(\d+):(\d+):(\d+\.\d+)/)) {
          duration = parseInt(match[1], 10) * 3600 + parseInt(match[2], 10) * 60 + parseFloat(match[3]);
          return winston.debug('Parsed duration', {
            file: src,
            duration: duration
          });
        }
      });
      return ffmpeg.on('exit', function(code, signal) {
        var name;
        if (code) {
          return cb({
            msg: 'File could not be added',
            file: src,
            retcode: code,
            signal: signal
          });
        }
        winston.info('File added OK', {
          file: src
        });
        name = path.basename(src).replace(/\..+$/, '');
        json.spritemap[name] = {
          start: offsetCursor,
          end: offsetCursor + duration,
          loop: name === argv.autoplay
        };
        offsetCursor += duration;
        return appendSilence(Math.ceil(duration) - duration + 1, dest, cb);
      });
    });
  };

  appendSilence = function(duration, dest, cb) {
    var buffer, ffmpeg;
    ffmpeg = spawn('ffmpeg', ['-f', 's16le', '-i', 'pipe:0'].concat(wavArgs).concat('pipe:1'));
    buffer = new Buffer(Math.round(44100 * 2 * numChannels * duration));
    buffer.fill(null);
    ffmpeg.stdin.end(buffer);
    ffmpeg.stdout.pipe(fs.createWriteStream(dest, {
      flags: 'a'
    }));
    return ffmpeg.on('exit', function(code, signal) {
      if (code) {
        return cb({
          msg: 'Error adding silence gap',
          retcode: code,
          signal: signal
        });
      }
      winston.info(duration.toFixed(2) + 's silence gap added OK');
      offsetCursor += duration;
      return cb();
    });
  };

  exportFile = function(src, dest, ext, opt, cb) {
    var ffmpeg, outfile;
    outfile = dest + '.' + ext;
    ffmpeg = spawn('ffmpeg', ['-y', '-f', 's16le', '-i', src].concat(opt).concat(outfile));
    return ffmpeg.on('exit', function(code, signal) {
      if (code) {
        return cb({
          msg: 'Error exporting file',
          format: ext,
          retcode: code,
          signal: signal
        });
      }
      if (ext === 'aiff') {
        return exportFileCaf(outfile, dest + '.caf', function(err) {
          json.resources.push(dest + '.caf');
          fs.unlinkSync(outfile);
          return cb(err);
        });
      } else {
        winston.info("Exported " + ext + " OK", {
          file: outfile
        });
        json.resources.push(outfile);
        return cb();
      }
    });
  };

  exportFileCaf = function(src, dest, cb) {
    var afconvert;
    if (process.platform !== 'darwin') {
      return;
    }
    afconvert = spawn('afconvert', ['-f', 'caff', '-d', 'ima4', src, dest]);
    return afconvert.on('exit', function(code, signal) {
      if (code) {
        return cb({
          msg: 'Error exporting file',
          format: 'caf',
          retcode: code,
          signal: signal
        });
      }
      winston.info('Exported caf OK', {
        file: dest
      });
      return cb();
    });
  };

  processFiles = function() {
    return async.forEachSeries(files, function(file, cb) {
      return appendFile(file, tempFile, cb);
    }, function(err) {
      var formats;
      if (err) {
        return winston.error('Error processing file', err);
      }
      formats = ['aiff', 'ac3 -acodec ac3', 'mp3 -ab 128 -f mp3', 'm4a', 'ogg -acodec libvorbis -f ogg'];
      return async.forEachSeries(formats, function(format, cb) {
        var ext, opt, _ref;
        _ref = format.split(' '), ext = _ref[0], opt = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
        winston.debug('Start export', {
          format: ext
        });
        return exportFile(tempFile, argv.output, ext, opt, cb);
      }, function(err) {
        var jsonfile;
        if (err) {
          return winston.error('Error exporting file', err);
        }
        if (argv.autoplay) {
          json.autoplay = argv.autoplay;
        }
        jsonfile = argv.output + '.json';
        fs.writeFileSync(jsonfile, JSON.stringify(json, null, 2));
        winston.info('Exported json OK', {
          file: jsonfile
        });
        fs.unlinkSync(tempFile);
        return winston.info('All done');
      });
    });
  };

  offsetCursor = 0;

  numChannels = 1;

  wavArgs = ['-ar', '44100', '-acodec', 'pcm_s16le', '-ac', numChannels, '-f', 's16le'];

  tempFile = mktemp('audio-sprite');

  winston.debug('Created temporary file', {
    file: tempFile
  });

  json = {
    resources: [],
    spritemap: {}
  };

  if (argv.silence) {
    json.spritemap.silence = {
      start: 0,
      end: argv.silence,
      loop: true
    };
    if (!argv.autoplay) {
      json.autoplay = 'silence';
    }
    appendSilence(argv.silence + 1, tempFile, processFiles);
  } else {
    processFiles();
  }

}).call(this);
