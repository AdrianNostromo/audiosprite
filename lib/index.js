// Generated by CoffeeScript 1.3.1
(function() {
  var NUM_CHANNELS, SAMPLE_RATE, appendFile, appendSilence, argv, async, child_process, exportFile, exportFileCaf, files, fs, json, makeRawAudioFile, mktemp, offsetCursor, optimist, path, processFiles, spawn, tempFile, util, wavArgs, winston, _;

  fs = require('fs');

  path = require('path');

  child_process = require('child_process');

  util = require('util');

  async = require('async');

  _ = require('underscore')._;

  winston = require('winston');

  optimist = require('optimist').options('output', {
    alias: 'o',
    "default": 'output',
    describe: 'Name for the output file.'
  }).options('log', {
    alias: 'l',
    "default": 'info',
    describe: 'Log level (debug, info, notice, warning, error).'
  }).options('autoplay', {
    alias: 'a',
    "default": null,
    describe: 'Autoplay sprite name'
  }).options('silence', {
    alias: 's',
    "default": 0,
    describe: 'Add special "silence" track with specified duration.'
  }).options('samplerate', {
    alias: 'r',
    "default": 44100,
    describe: 'Sample rate.'
  }).options('channels', {
    alias: 'c',
    "default": 1,
    describe: 'Number of channels (1=mono, 2=stereo).'
  }).options('rawparts', {
    alias: 'p',
    "default": '',
    describe: 'Include raw slices(for Web Audio API) in specified formats.'
  }).options('help', {
    alias: 'h',
    describe: 'Show this help message.'
  });

  argv = optimist.argv;

  winston.setLevels(winston.config.syslog.levels);

  winston.remove(winston.transports.Console);

  winston.add(winston.transports.Console, {
    colorize: true,
    level: argv.log,
    handleExceptions: true
  });

  winston.debug('Parsed arguments', argv);

  SAMPLE_RATE = parseInt(argv.samplerate);

  NUM_CHANNELS = parseInt(argv.channels);

  files = _.uniq(argv._);

  if (argv.help || !files.length) {
    if (!argv.help) {
      winston.error('No input files specified.');
    }
    winston.info('Usage: audiosprite [options] file1.mp3 file2.mp3 *.wav');
    winston.info(optimist.help());
    return;
  }

  mktemp = function(prefix) {
    var tmpdir;
    tmpdir = process.env.TMPDIR || '.';
    return path.join(tmpdir, prefix + '.' + ~~(Math.random() * 1e6));
  };

  spawn = function(name, opt) {
    winston.debug('Spawn', {
      cmd: name + ' ' + opt.join(' ')
    });
    return child_process.spawn(name, opt);
  };

  makeRawAudioFile = function(src, cb) {
    var dest;
    winston.debug('Start processing', {
      file: src
    });
    dest = mktemp('audiosprite');
    return fs.exists(src, function(exists) {
      var ffmpeg;
      if (!exists) {
        return cb({
          msg: 'File does not exist',
          file: src
        });
      }
      ffmpeg = spawn('ffmpeg', ['-i', path.resolve(src)].concat(wavArgs).concat('pipe:'));
      ffmpeg.stdout.pipe(fs.createWriteStream(dest, {
        flags: 'w'
      }));
      return ffmpeg.on('exit', function(code, signal) {
        if (code) {
          return cb({
            msg: 'File could not be added',
            file: src,
            retcode: code,
            signal: signal
          });
        }
        return cb(null, dest);
      });
    });
  };

  appendFile = function(name, src, dest, cb) {
    var reader, size, writer;
    size = 0;
    reader = fs.createReadStream(src);
    writer = fs.createWriteStream(dest, {
      flags: 'a'
    });
    reader.on('data', function(data) {
      return size += data.length;
    });
    return util.pump(reader, writer, function() {
      var duration;
      duration = size / SAMPLE_RATE / NUM_CHANNELS / 2;
      winston.info('File added OK', {
        file: src,
        duration: duration
      });
      json.spritemap[name] = {
        start: offsetCursor,
        end: offsetCursor + duration,
        loop: name === argv.autoplay
      };
      offsetCursor += duration;
      return appendSilence(Math.ceil(duration) - duration + 1, dest, cb);
    });
  };

  appendSilence = function(duration, dest, cb) {
    var buffer, writeStream;
    buffer = new Buffer(Math.round(SAMPLE_RATE * 2 * NUM_CHANNELS * duration));
    buffer.fill(null);
    writeStream = fs.createWriteStream(dest, {
      flags: 'a'
    });
    writeStream.end(buffer);
    return writeStream.on('close', function() {
      winston.info('Silence gap added', {
        duration: duration
      });
      offsetCursor += duration;
      return cb();
    });
  };

  exportFile = function(src, dest, ext, opt, cb) {
    var ffmpeg, outfile;
    outfile = dest + '.' + ext;
    ffmpeg = spawn('ffmpeg', ['-y', '-ac', NUM_CHANNELS, '-f', 's16le', '-i', src].concat(opt).concat(outfile));
    return ffmpeg.on('exit', function(code, signal) {
      if (code) {
        setTimeout((function() {}), 20000);
        return;
      }
      if (code) {
        return cb({
          msg: 'Error exporting file',
          format: ext,
          retcode: code,
          signal: signal
        });
      }
      if (ext === 'aiff') {
        return exportFileCaf(outfile, dest + '.caf', function(err) {
          json.resources.push(dest + '.caf');
          fs.unlinkSync(outfile);
          return cb(err);
        });
      } else {
        winston.info("Exported " + ext + " OK", {
          file: outfile
        });
        json.resources.push(outfile);
        return cb();
      }
    });
  };

  exportFileCaf = function(src, dest, cb) {
    var afconvert;
    if (process.platform !== 'darwin') {
      return;
    }
    afconvert = spawn('afconvert', ['-f', 'caff', '-d', 'ima4', src, dest]);
    return afconvert.on('exit', function(code, signal) {
      if (code) {
        return cb({
          msg: 'Error exporting file',
          format: 'caf',
          retcode: code,
          signal: signal
        });
      }
      winston.info('Exported caf OK', {
        file: dest
      });
      return cb();
    });
  };

  processFiles = function() {
    var formats, rawparts;
    formats = {
      aiff: [],
      ac3: '-acodec ac3'.split(' '),
      mp3: '-ab 128 -f mp3'.split(' '),
      m4a: [],
      ogg: '-acodec libvorbis -f ogg'.split(' ')
    };
    rawparts = argv.rawparts.split(',');
    return async.forEachSeries(files, function(file, cb) {
      return makeRawAudioFile(file, function(err, tmp) {
        var name;
        if (err) {
          return winston.error('Error processing file', err);
        }
        name = path.basename(file).replace(/\..+$/, '');
        return appendFile(name, tmp, tempFile, function(err) {
          fs.unlinkSync(tmp);
          return cb();
        });
      });
    }, function(err) {
      if (err) {
        return winston.error('Error adding file', err);
      }
      return async.forEachSeries(Object.keys(formats), function(ext, cb) {
        winston.debug('Start export', {
          format: ext
        });
        return exportFile(tempFile, argv.output, ext, formats[ext], cb);
      }, function(err) {
        var jsonfile;
        if (err) {
          return winston.error('Error exporting file', err);
        }
        if (argv.autoplay) {
          json.autoplay = argv.autoplay;
        }
        jsonfile = argv.output + '.json';
        fs.writeFileSync(jsonfile, JSON.stringify(json, null, 2));
        winston.info('Exported json OK', {
          file: jsonfile
        });
        fs.unlinkSync(tempFile);
        return winston.info('All done');
      });
    });
  };

  offsetCursor = 0;

  wavArgs = ['-ar', SAMPLE_RATE, '-ac', NUM_CHANNELS, '-f', 's16le'];

  tempFile = mktemp('audiosprite');

  winston.debug('Created temporary file', {
    file: tempFile
  });

  json = {
    resources: [],
    spritemap: {}
  };

  if (argv.silence) {
    json.spritemap.silence = {
      start: 0,
      end: argv.silence,
      loop: true
    };
    if (!argv.autoplay) {
      json.autoplay = 'silence';
    }
    appendSilence(argv.silence + 1, tempFile, processFiles);
  } else {
    processFiles();
  }

}).call(this);
